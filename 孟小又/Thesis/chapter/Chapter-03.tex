\setcounter{chapter}{2}

\chapter{体积雾和体积光模拟算法}
\label{chap3}
用Ray-marching算法和阴影贴图算法生成体积雾和体积光是近年来比较流行的方法，本文算法在原有算法\scite{toth2009real}\scite{vos2014volumetric}的基础上进行改进，改进点包括四点：
\begin{itemize}
\item 提高Ray-marching算法的效率；
\item 支持多光源场景的体积雾和体积光的渲染；
\item 通过提高阴影的质量来提升体积光渲染的效果；
\item 兼容性好，兼容前向着色渲染管线、延迟着色管线和存在透明物体的场景；
\end{itemize}

本文算法主要包括，介质密度的生成、Ray-marching算法的改进，级联阴影的实现与改进，多光源的预处理步骤。本章将对整个渲染流程以及涉及的算法进行详细地描述与分析。首先概述算法的核心思想，然后对算法的基本原理和实现细节进行了叙述，最后对本文所采用的方法进行了分析与总结。

\section{算法概述}
本文算法将采样点的光照计算部分和Ray-marching积分计算部分解耦，提高原有算法的效率。在章节\ref{2DRM} 中详细描述了二维Ray-marching 算法的步骤，在二维Ray-marching 算法中，在片元着色器进行Ray-marching 步骤，从视点出发在视线上每隔一定的步长采样一次，计算出当前点的光照值和阴影值，每次得到当前点的光照计算值时，与前面所有点的光照结果做积分运算，求得当前点的消光系数和累计光照值，Ray-marching的终点为视线与场景的交点。虽然光线与光线是并行计算关系，但是光线上每个采样点的计算存在依赖关系，当前采样点的累计光照值依赖于前面所有采样点的计算值。假设每根光线上采样点数量为$K$，每个点自身的光照计算所需时间为$M$，与前面所有采样点进行积分求和的计算时间为$N$，屏幕分辨率为$W\times H$，在片元着色器中Ray-marching步骤所需的总时间为$K\times W\times H\times \left( M+N \right)$。虽然Ray-marching步骤中的累计光照值的运算依赖于每个采样点的光照计算值，但是每个采样点的光照计算步骤互相独立，所以本文算法将每个采样点的光照计算从Ray-marching 步骤中解耦，将这个计算量大但是相互之间独立的步骤使用三维计算器着色器完成，这个步骤的结果存储在三维纹理中，传入后续的Ray-marching步骤中供光照积分运算使用，在Ray-marching 步骤，使用二维计算着色器进行计算，和片元着色器中的计算方式一致，本文算法中这两个步骤的总时间为$M+K\times W\times H\times N$，本文算法与原有算法相比在Ray-marching步骤缩短的时间理论值为$\left( K\times W\times H-1 \right)\times M$，在章节\ref{computeSpeedcompare}中会有实际的实验数据表明这个步骤效率的提升对整个渲染流程效率提升的影响。


本文算法可以支持多光源场景，透明场景，兼容前向着色渲染管线和延迟着色管线，不需要额外的渲染绘制遍进行处理。在极线采样算法渲染体积光\scite{yusov2014high}中，需要对Ray-marching 算法进行预处理，使用光源的相机矩阵和透视矩阵对Ray-marching 投射的光线进行预筛选，通过减少光线数量来提高效率，这个算法只支持单光源处理，此外由于光线投射数量的减少，这个算法只能适用于户外场景，对于近处的体积光模拟效果并不理想。游戏《杀戮地带：暗影坠落》\scite{vos2014volumetric} 中模拟体积光的算法为了提高效率，只在光源范围内进行Ray-marching，需要提前渲染光源几何体并且记录该几何体的深度影响范围，该步骤使得这个算法只能在光源可见的情况下生效，并且如果一个像素点如果同时受几个光源影响，这个算法需要改变存储光源几何体深度的数据结构，二维纹理没有办法满足其需求。光源对粒子的影响本质上是影响粒子的内散射光线，本文算法在三维计算着色器中处理所有光源对粒子的光照影响，根据每个光源的位置信息、颜色信息、衰减函数、阴影贴图和相位方程等可以求得其对粒子的内散射光线的贡献值，在光照计算步骤不需要预处理，且每个光源的计算过程与其他光源没有耦合，同一个粒子受多个光源影响只要分别计算出每个光源的影响值然后进行叠加，这个步骤在章节\ref{multilight}中有详细说明。计算出光源对粒子的影响后，我们在积分过程中使用每个点的内散射光线和消光系数计算出当前采样点的累积光线值，并将累积光线值存储到对应的三维纹理中。将雾效和体积光应用到场景中时，我们使用场景的深度值作为参考值去采样三维纹理，得到当前深度对应的雾效或体积光的颜色。在本文算法中，计算出每个粒子最终的累积光线值以后，在后续处理过程中，唯一的传入参数是场景的深度，在前向着色渲染管线和延迟着色管线中场景深度很容易获得。此外对透明物体的处理，由于其渲染流程的特殊性，比较主流的透明物体渲染算法\scite{Mammen:89}\scite{Everitt:02} 都保存了每个透明片元的深度，得到透明物体片元的深度值以后，我们可以像处理不透明物体的片元一样得到当前透明片元雾的颜色值或体积光的影响值，本文算法在没有改变透明物体的渲染流程和方式的情况下可以完成透明物体的雾效和体积光的渲染。


本文算法对阴影算法部分进行改进，使用ESM技术对级联阴影进行滤波。原有算法中使用级联阴影算法生成场景的阴影，级联阴影的思想和LOD\scite{luebke2003level}的思想很相近，在靠近相机的地方使用更精细的阴影贴图纹理，远处的地方使用粗糙的阴影贴图纹理，将纹理的分辨率进行合理划分，提高场景的阴影质量。级联阴影因为需要生成多张阴影纹理，所以会给内存增加负担，此外当相机很接近物体时，总会存在因为阴影纹理分辨率不够而产生走样的效果，所以本文算法使用指数阴影贴图技术去解决这两个问题，指数阴影贴图技术对原有的级联阴影贴图进行滤波处理，这个操作解决了分辨率较低的阴影贴图的走样问题，在章节\ref{shadowfilter}中会对这部分内容做详细的分析和描述。


本文算法的主要思想是将Ray-marching步骤和粒子的光照计算等步骤从原有算法中解耦出来，将这些步骤计算得到的结果暂时保存下来，供后续步骤使用。本文算法使用计算着色器(Compute Shader) 来处理和粒子相关的光照计算，提高渲染的效率。介质中的每个粒子需要单独计算内散射光线并保存内散射的结果，本文算法用三维纹理来存储每个粒子的内散射光线和消光系数。2009 年，Kaplanyan 等人\scite{kaplanyan2009light} 提出将三维纹理应用到游戏和电影的制作中，作为渲染过程的中间存储器。在2010年，Magnus Wrenninge 等人\scite{wrenninge2010volumetric}将这个想法应用到特效行业，计算单次和多次散射效应，本文算法受其影响使用三维纹理的数据结构。此外，使用指数阴影贴图技术优化级联阴影相对于其他阴影滤波技术来说有效率、效果和内存上的优势，这部分会在章节\ref{Shadow} 中做详细描述。

\section{算法步骤}
本文算法分为以下几步：
\begin{enumerate}
\item 生成级联阴影贴图并使用指数阴影贴图技术滤波；
\item 计算每个粒子的内散射光线；
\item Ray-marching求解体积雾或者体积光的颜色；
\item 将雾效与渲染场景相结合；
\end{enumerate}

本文算法详细的算法步骤描述如下：本文算法所有步骤在视锥体中完成，Ray-marching是在视锥体中进行，Ray-marching步骤的作用是对视线上所有采样点的内散射光线值进行积分，求得雾和体积光的颜色值。所以本文算法第一步是求每个粒子的内散射值，计算内散射值所需的输入参数为：粒子的密度，相位方程，粒子的位置，场景中光源的信息。计算出每个粒子的内散射值以后再用Ray-marching算法做积分运算，求得雾效，其中单个粒子的内散射值存放在三维纹理中，供Ray-marching步骤使用，Ray-marching 步骤的结果同样存放在三维纹理中，供后续效果叠加步骤使用。本文算法在GPU上的主要渲染绘制遍和使用的数据结构
如图\ref{pic_algorithm_gen}所示。
\begin{figure}[htbp]
    \centering
    \includegraphics[width=.7\linewidth]{figures/algorithm_gen}
    \caption{算法步骤概要图}
    \label{pic_algorithm_gen}
\end{figure}

图\ref{pic_algorithm_gen}中灰色箭头代表数据的传递过程，红色箭头代表渲染过程。绿色长方形代表二维纹理贴图，蓝色长方体代表三维纹理，这些数据结构都用来存放计算步骤的中间结果。首先，生成多张级联阴影贴图，将这些贴图经过FS(Fragment Shader)的滤波处理变成指数阴影贴图，指数阴影贴图在计算密度和光照部分的CS(compute Shader)中用到，这个CS 的处理结果是单个粒子的散射值，将单个粒子的散射值传进第三个CS 中求解散射积分方程\ref{eq:LTE-10}，得到此方程的近似解。最后在FS 中，使用散射方程的近似解、场景的深度纹理和颜色纹理求得最终输出到屏幕上的像素值。下面小节将会对本文算法每个步骤进行详细描述。


\section{单个粒子的内散射光线计算}
在视线上积分求取雾效的颜色首先需要知道每个粒子的内散射光线值，所以这一小节首先介绍如何计算单个粒子的内散射光线。计算单个粒子的内散射值需要计算出粒子的密度，粒子的位置信息，场景中每个光源对粒子内散射光线的贡献值，因此首先我们需要预计算粒子内散射光线所需要的信息，然后介绍如何利用这些信息计算粒子的内散射值。
\subsection{介质密度生成}
因为我们需要用密度来计算散射需要的消光系数，所以介质密度生成是求解散射方程的第一步。介质密度的生成有三种，第一种是函数模拟，第二种是用柏林噪声生成雾的密度分布纹理，第三种由美术人员使用美术工具生成。

函数模拟的方式如下。以雾为例子，雾的密度比空气大，雾相对来说会聚集在地面附近，雾的密度是在高度上呈指数分布趋势，雾的密度分布函数如公式\ref{eq:Density} 所示。
\begin{eqnarray}
    d\left( h \right)={{d}_{0}}\times {{e}^{-hD}}
    \label{eq:Density}
\end{eqnarray}
其中$d\left( h \right)$表示高度为$h$时粒子的密度，$d_0$ 代表密度的基准值，通常情况下为地面处的密度。系数$D$用来表示粒子密度的类型，$D$越大，随着高度的变化，密度下降速度越快。


实际场景中，雾的密度分布不均匀的因素有很多种，只用高度作为输入参数去干扰雾的分布不够真实，并且相机只有在远景视角才能体现。为了使密度的分布更加自然，需要用噪声纹理去干扰雾的分布，但是使用普通随机算法生成的噪声纹理与自然界中物体的随机分布有很大差别，模拟出来的效果不够真实。本文算法采用柏林噪声\scite{Per1985An}去干扰雾的分布，柏林噪声在图形学中的应用广泛，常用于自然现象的模拟，可以得到很好的效果。介质的粒子在三维空间中分布，所以我们需要三维的柏林噪声纹理，柏林噪声需要一个种子作为输入参数，我们使用位置信息作为柏林噪声的输入参数。柏林噪声的生成如图\ref{pic-perlinNoise}中左图所示所示。假设点$M$是三维空间中的一个粒子，坐标为$\left ( x,y,z \right )$，这个粒子的噪声值由其周围的八个顶点决定，每个顶点有一个伪随机的梯度向量，三维空间中这些梯度向量不是完全随机的，是单位正方体的中点指向每条边中点的12个向量，每个顶点从这十二条向量中随机选取一条。2002 年，ken Perlin\scite{perlin2002improving} 解释了选用这12 个向量的原因。顶点$A$的梯度向量为$\vec a$，$A$点到$M$点的向量为$\vec b$，$A$点处的噪声值为$\vec a \bullet \vec b$，$A$点对$M$点的$X$、$Y$、$Z$ 三个方向上的影响由向量$\vec c$ 的三个分量决定，$\vec c=\left(x,y,z\right)-\left( \left\lfloor x \right\rfloor ,\left\lfloor y \right\rfloor ,\left\lfloor z \right\rfloor  \right)$，使用插值函数$fade$ 计算三个分量上的影响因子$u$、$v$、$w$，插值函数为$6t^5 - 15t^4 + 10t^3$，因为这个函数的一阶导数和二阶导数在0和1处都为0，所以生成的噪声纹理更加平滑。计算$M$点的噪声值时，首先按照上述步骤计算出每个顶点的噪声值，然后使用向量$\vec c$计算出$X$、$Y$、$Z$三个方向上$M$ 点的影响因子，最后计算出$M$ 点的噪声值。本文算法中三维柏林噪声纹理的渲染结果如图\ref{pic-perlinNoise} 中右图所示。
\begin{figure*}[!htb]
\makeatletter
\renewcommand{\@thesubfigure}{\hskip\subfiglabelskip}
\makeatother
    \centering
    \subfigure[柏林噪声生成示意图]{
    \includegraphics[width=0.45\textwidth, height=5.5cm]{figures/perlin3D}}
    \subfigure[三维柏林噪声渲染图]{
    \includegraphics[width=0.45\textwidth, height=5.5cm]{figures/perlinrendering}}
    \caption{柏林噪声}
    \label{pic-perlinNoise}
\end{figure*}

美术工具预先生成的方式不属于算法的范畴，不做过多赘述，美术生成雾和体积光的体密度纹理，在程序中密度可以通过采样直接得到，渲染效果和体密度纹理的分布有关。

\subsection{三维纹理存储结构}
因为本文算法在三维空间中进行Ray-marching步骤，介质中的微粒在三维空间中存在，所以我们可以将介质所在的空间假设为场景中的一个长方体，长方体被分割成很多个微型立方体，每个立方体中心是粒子的坐标，计算粒子的密度值时，函数的输入参数为粒子坐标位置$Y$ 方向的值，柏林噪声的输入参数为粒子的坐标位置。三维纹理可以作为存储结构使用，能够满足上述所有需求。

在计算散射的过程中，需要预计算每个粒子的内散射光线值，每个粒子的内散射光线值存在三维纹理中，供后续Ray-marching步骤计算累计散射光线值使用，累计散射光线值也需要用一个三维纹理进行存储，作为场景添加雾效和体积光的步骤中的输入参数，因此本文算法需要两个三维纹理作为中间存储器。纹理有四个通道(RGBA)，每个通道存储16 位的浮点数类型。考虑到内存的开销，我们选用分辨率较低的三维纹理，本文算法中使用的分辨率为128×128×64。

因为需要计算出三维纹理中每个纹理代表的粒子的位置，所以将三维纹理坐标系映射到屏幕坐标系是一个关键的步骤。三维纹理与屏幕坐标系的映射如图\ref{pic_3DTextureMapping} 所示。经过透视投影矩阵的处理，场景中的点会被投射到二维的屏幕中，三维纹理中每个纹理对应的点也会被映射到屏幕上，三维纹理的$X$，$Y$轴代表屏幕的$X$，$Y$方向，$Z$ 轴代表屏幕$Z$ 方向上的深度。根据透视投影近大远小的原则，靠近相机的地方需要更多的细节描述。基于这个原理，我们在用三维纹理描述屏幕空间下$Z$ 方向的分布时不采用线性映射，采用指数映射。在经过透视投影矩阵处理以后，相机近平面的屏幕深度值为0，远平面为1，所以三维纹理中$Z=0$ 的采样点所代表的深度为0，$Z=n$($n$为$Z$方向的最大采样深度，本文算法中$n=64$)的采样点所代表的深度为1，在本文算法中，我们对$0-1$ 之间的深度进行分割，分成64份，越靠近0 的地方，分布越密，越靠近1 的地方越稀疏，所以三维纹理中的深度分布如下，$Z=0$的采样点深度为${{\left( \frac{1}{64} \right)}^{2}}$，$Z=1$的采样点深度为${{\left( \frac{2}{64} \right)}^{2}}$，$Z=64$的采样点深度为${{\left( \frac{64}{64} \right)}^{2}}$。 这种选取步长的方式其实是将计算资源分配更加合理，靠近相机的场景细节部分会被更加充分的考虑。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=.7\linewidth]{figures/3DTextureMapping}
    \caption{三维纹理空间映射图}
    \label{pic_3DTextureMapping}
\end{figure}

得出三维纹理坐标系和屏幕空间坐标系的映射关系以后，通过计算得到每个粒子的坐标位置（这个步骤在章节\ref{singleinscattering} 中会详细描述），将坐标位置作为上一小节密度公式的输入参数和柏林噪声的输入参数可以得到不同的密度分布，使用坐标信息和密度信息就可以进行后续的光照计算。

为了节约内存开销，本文算法使用的纹理分辨率较低，为128×128×64，对于$X$、$Y$轴而言，因为屏幕上一个区域内的像素点采样得到的密度值为同一个值，所以低分辨率下雾和体积光的效果会不够精致，雾会产生小正方行状的块状分布。相对于二维Ray-marching 算法来说，三维Ray-marching 算法得到的结果会好很多。因为二维Ray-marching 算法步骤中，密度纹理值只和$X$、$Y$ 方向有关，为了体现深度上的差异，通常会随机选取一个值来干扰密度纹理的分布，使其在深度上有差异，但是实际上这个值和深度没有任何关系。考虑到这个问题，有些算法会采用双边上采样\scite{kopf2007joint} 来修正结果，但是当空间中存在细小几何体或者空间比较复杂的情况下这种处理方式仍会失效。本文算法不会受这个问题影响，因为对屏幕上每个像素而言，其采样的纹理值和其空间位置有关，空间位置包括这个像素点的深度值。


在实际操作过程中，二维Ray-marching算法和三维算法的密度纹理采样过程比较如图\ref{pic1-2D3Drm}所示。在二维Ray-marching 算法中，$A$点和$B$点对应的采样点为二维纹理中相同的位置，但是实际过程中，他们在空间中的密度分布并不不一样。在三维纹理中，采样坐标除了受$X$、$Y$方向的值影响，还受深度影响，所以$A$ 点和$B$点可以分别得到精确的密度值。二维Ray-marching算法和三维Ray-marching算法相同分辨率下得到的效果如图\ref{pic1-2D3Drmrendering}所示。

\begin{figure*}[!htb]
\makeatletter
\renewcommand{\@thesubfigure}{\hskip\subfiglabelskip}
\makeatother
    \centering
    \subfigure[二维Ray-marching采样]{
    \includegraphics[width=0.45\textwidth, height=5.0cm]{figures/2Drm}}
    \subfigure[三维Ray-marching采样]{
    \includegraphics[width=0.45\textwidth, height=5.0cm]{figures/3Drm}}
    \caption{二维和三维Ray-marching采样过程对比}
    \label{pic1-2D3Drm}
\end{figure*}

\begin{figure*}[!htb]
\makeatletter
\renewcommand{\@thesubfigure}{\hskip\subfiglabelskip}
\makeatother
    \centering
    \subfigure[二维Ray-marching雾的效果图]{
    \includegraphics[width=0.45\textwidth, height=5.0cm]{figures/keliwu}}
    \subfigure[三维Ray-marching雾的效果图]{
    \includegraphics[width=0.45\textwidth, height=5.0cm]{figures/keliwu2}}
    \caption{二维和三维Ray-marching效果图对比}
    \label{pic1-2D3Drmrendering}
\end{figure*}

此外为了提高场景的效果，更好地解决低分辨率下产生的问题，本文算法还做了额外优化工作，这会在章节\ref{Shadow}中详细描述。

\subsection{多光源}
\label{multilight}
计算内散射光线首先得知道当前粒子的入射光线，米氏散射和光的波长无关，所以我们计算入射光线时可以将多个光源的入射光线强度叠加，在计算散射的时候对总入射强度进行处理。在实际渲染过程中，有三种光源，平行光、平行光和聚光灯。因为三种光源计算光线的方式不一样，所以本章节中会分开描述。
\subsubsection{平行光}
平行光通常用来模拟太阳光，从固定方向照射到物体上，光线的方向互相平行，平行光的强度为固定值，没有距离的衰减。平行光的阴影可以用级联阴影生成，级联阴影的生成在章节\ref{Shadow}中有详细的描述。对于平行光的光照处理比较简单，介质中微粒接受平行光的入射光线计算公式如\ref{eq:Directlight} 所示，平行光的入射光线为入射强度与颜色的乘积。
\begin{eqnarray}
   {{L}_{d}}={{L}_{0}}\times {{C}_{RGBA}}\times V
    \label{eq:Directlight}
\end{eqnarray}

${L}_{d}$为入射光线的值，${L}_{0}$为平行光的强度，${C}_{RGBA}$为平行光的颜色值，$V$为阴影因子。

\subsubsection{点光源}
点光源没有固定方向，从一点出发，向各个方向均匀地发射光线的光源为点光源，点光源的衰减和距离有关，当物体离光源越远时衰减效果更加明显。在一般情况下，会给定一个简单的假设，光线强度和距离的平方成反比。光强计算如公式\ref{eq:pl_attenuation1}所示。
\begin{eqnarray}
    {{L}_{\text{intensity}}}=\frac{{{L}_{0}}}{di{{s}^{2}}}
    \label{eq:pl_attenuation1}
\end{eqnarray}

这个公式基本能满足衰减的要求，但是产生的视觉效果不太理想，比如距离很近的时候，因为分母很小，所以光线的强度会趋近于无穷大，而且除了初始光强，没有其他系数来控制衰减程度。所以我们倾向于在这个公式的基础上加另外一些控制系数。如公式\ref{eq:pl_attenuation2}所示。
\begin{eqnarray}
    {{L}_{\text{intensity}}}\text{=}\frac{{{L}_{0}}}{\text{Att}_{con}+\text{Att}_{lin}\times d+\text{Att}_{\exp }\times {{d}^{2}}}
    \label{eq:pl_attenuation2}
\end{eqnarray}

这个公式中，加了三个光的衰减系数（常量系数，线性系数，指数系数）。当常量系数和线性系数值为0，指数系数值为1 时，便是公式\ref{eq:pl_attenuation1}。当常量系数为1 时，在距离为0时，光强是程序设置的最大光强。通过调整线性系数和指数系数可以控制衰减的快慢，得到不同的灯光效果。点光源的入射光线值计算如公式\ref{eq:Pointlight} 所示。
\begin{eqnarray}
{{L}_{\text{d}}}\text{=}\frac{{{L}_{0}}\times {{C}_{RGBA}}\times V}{\text{Att}_{con}+\text{Att}_{lin}\times d+\text{Att}_{\exp}\times {{d}^{2}}}
    \label{eq:Pointlight}
\end{eqnarray}

因为点光源向各个方向发射光线，在计算点光源阴影时，不能使用基本的阴影贴图。在点光源的阴影贴图中，需要保存各个方向的阴影贴图。我们使用立方体贴图来保存六个面的深度值。如图\ref{pic_pl_shadow} 所示，以点光源为原点，上下左右前后六个面都需要生成阴影贴图，每个面有单独的光源变换矩阵，经过变换矩阵的处理，得到阴影贴图，存放在立方体贴图对应的面。
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.6\textwidth,height=6.0cm]{figures/pl_shadow}
    \caption{点光源阴影}
    \label{pic_pl_shadow}
\end{figure}

用这个方法创建点光源的深度值贴图需要将场景重复渲染6次，每次可以得到一个面的阴影深度值。多次进行渲染调用会降低场景的效率，在场景特别大的时候这个弊端会更加明显。其实渲染场景的六次过程中，只是将场景中的点或者三角形做了6次不同的矩阵变换，矩阵中变化的只有相机矩阵。通常来说矩阵变换是在顶点着色器中完成，为了方便处理，我们可以借助几何着色器来帮助渲染立方体贴图。具体步骤如下：
\begin{itemize}
\item 创建一个立方体贴图，为立方体每个面绑定一个二维的纹理图像用来保存点光源6 个面的深度值，为每个二维的纹理设置纹理参数；
\item 使用$glFramebufferTexture$函数将立方体贴图绑定到到帧缓冲区的深度区域，因为立方体纹理贴图只关心深度值，不需要往颜色缓冲区输出颜色，所以将$glDrawBuffer$ 和$glReadBuffer$ 函数的参数都设置为$GL\_NONE$;
\item 为点光源的6个面计算其单独的变换矩阵。变换矩阵包括投影矩阵和相机矩阵。在设置投影矩阵时，将视野参数设置为$90_。$，确保视野能够填满立方体贴图的每个面;
\item 在渲染过程中启用几何着色器，在顶点着色器阶段，我们对顶点只做模型矩阵变换，几何着色器阶段的输入是以三角形为单位处理三角形的三个顶点，每个顶点需要使用到步骤三中计算的变换矩阵进行6 次变换生成6个不同的顶点，所以几何着色器阶段输出为18个顶点，为了确保几何着色器可以帮助我们将这6个面的三角形传送到立方体贴图对应的面上，我们需要使用几何着色器中的内建变量$gl\_Layer$，为同一组三角形的顶点设置相同的$gl\_Layer$ 值，几何着色器就会把这组顶点传送到对应的立方体贴图中。在片元着色器阶段我们计算阴影的深度值并将深度值写到对应的纹理中；
\item 在计算光照阶段，我们将片元的世界坐标系和点光源的世界坐标的差值作为采样坐标对立方体纹理进行采样得到正确的深度值，将这个值与片元在光空间下的深度值进行比较，计算出阴影因子；
\end{itemize}
阴影因子求出以后，根据公式\ref{eq:Pointlight}便可以计算出点光源的入射光线值。

\subsubsection{聚光灯}
聚光灯是三种灯光里比较复杂的一种灯光。聚光灯可以理解为有范围的点光源，聚光灯有位置信息，我们需要给它指定一个固定的方向，它的光线只分布在圆锥形的空间中，并且光线也会像点光源的光线一样随着距离而不断减弱。手电筒是典型的聚光灯。聚光灯有三个参数：位置信息、聚光灯的方向、光线分布的圆锥形的锥体角。下面我们要讨论的是怎么判断物体是否受聚光灯影响，聚光灯的衰减因子计算和聚光灯的阴影计算，通过这三个系数的计算我们才能最终得到聚光灯的入射值。
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth,height=5.0cm]{figures/splight}
    \caption{聚光灯图示}
    \label{pic_splight}
\end{figure}

如图\ref{pic_splight}所示，聚光灯的位置为$position$，锥体角为$\theta$，方向为$dir$。 物体$a$ 和物体$b$与聚光灯位置所形成的射线与聚光灯的方向形成的夹角分别为$\alpha$ 和$\beta$，我们通过判断夹角与$\theta$ 角的大小，就可以得出物体是否受聚光灯的影响。影响因子$\lambda$计算如公式\ref{eq:splinf}所示。
\begin{eqnarray}
\lambda \text{=}\left\{ \begin{matrix}
   0 & \cos x\ge \cos \theta   \\
   1 & \cos x<\cos \theta   \\
\end{matrix} \right.
    \label{eq:splinf}
\end{eqnarray}

聚光灯的衰减因子和点光源有部分的相同，聚光灯的强度也会随着距离衰减，计算公式为\ref{eq:pl_attenuation2}，将聚光灯的这种衰减系数记为$A_1$。 现实场景中，聚光灯照亮的区域，中心部分最亮，亮度从中心向照亮区域的边缘慢慢衰减。因为聚光灯的夹角范围一般不超过${45}^{\circ }$，所以边缘区域的距离和中心距离相差不大，没有办法用距离的衰减去模拟这个效果。所以在距离衰减的基础上，算法还需要考虑角度对光线强度的影响，角度的余弦值在${0}^{\circ}-{45}^{\circ}$之间是单调递减，可以满足光线的衰减分布，但是$cos{{0}^{\circ }}$ 值为1，$cos{{45}^{\circ }}$ 值为0.7071，两个角度之间余弦值的差距不大，当聚光灯角度较小时，差距更小，人眼对这种小范围的差距不太敏感，所以需要将余弦值的差距变大，对其做一个简单的线性映射，将$[x,1.0]$ 的值映射到$[0.0,1.0]$，$x$表示聚光灯最大角度的余弦值。映射关系如公式\ref{eq:splA2} 所示。
\begin{eqnarray}
    A_2=\frac{m-x}{1.0-x}
    \label{eq:splA2}
\end{eqnarray}

这个公式表示，当角度的余弦值为$m$时，经过映射得到的角度衰减因子记为$A_2$，当$m=x$ 时，衰减值为0，当$m=1.0$时，衰减值为1，满足要求。

聚光灯的阴影使用阴影贴图\scite{LV00}生成，在这里不做赘述。由公式\ref{eq:pl_attenuation2}、 公式\ref{eq:splinf}和公式\ref{eq:splA2}可知，聚光灯的入射光线值计算如公式\ref{eq:spotlight} 所示。
\begin{eqnarray}
    {{L}_{d}}={{L}_{0}}\times {{C}_{RGBA}}\times V\times \lambda \times {{A}_{1}}\times {{A}_{2}}
    \label{eq:spotlight}
\end{eqnarray}

\subsubsection{小结}
本小结讲述了本文算法对场景中三种光源的处理方式，三种光源的处理方式各不干扰，在这个步骤中，只需要计算出每个光源对粒子所贡献的入射光线的总和供后续计算使用。这种计算量很大但是与其他步骤耦合度不高的部分可以使用计算着色器进行处理，提高渲染效率，这点会在后续章节中做详细描述。

\subsection{单个粒子的散射计算}
\label{singleinscattering}
单个粒子的散射计算的准备工作包括阴影因子计算、密度计算、三维纹理的应用、光源入射光线的计算，这些都在前面章节有过详细的描述，这个小节主要描述怎么在计算着色器中计算单个粒子的散射，包括内散射值和消光系数，并将最终结果存放到三维纹理中。


为了数据存储的方便，本文算法将单个粒子的散射计算放在相机空间下完成，三维纹理中的每个采样点表示视线上的粒子。以128×128×64 的三维为例，在相机空间下，一共投射128×128 根光线，每根光线上有64个微粒。每个微粒计算出密度、阴影值、消光系数的指数值和入射光线值。这些系数的计算流程已经在前面章节做了描述，但是密度计算使用柏林噪声进行处理时的输入参数为粒子的世界坐标系下的位置，计算阴影值时，也需要粒子的位置信息，在散射计算之前需要得到每个粒子相应的世界坐标系下的位置。


本例中使用一个128×128×64的计算着色器来计算每个粒子所需要的值。可以理解为计算着色器的每个单元和三维纹理的采样点一一对应。三维纹理每个采样点的世界坐标系的位置需要在计算着色器中计算并使用。由于从三维纹理直接映射到世界坐标系比较麻烦，所以需要通过NDC(Normalized Device Coordinate) 坐标系作为中间桥梁，将三维纹理的纹理坐标先映射到NDC 坐标系，再由NDC 坐标系转化到世界坐标系中。由图\ref{pic_3DTextureMapping} 可知，三维纹理的$X$，$Y$，$Z$轴与相机空间下的$X$，$Y$，$Z$轴保持一致。经过投影矩阵，$X$，$Y$轴的分量在NDC 坐标系中的映射为$[-1.0,1.0]$，$Z$轴映射为$[0.0,1.0]$。 这个步骤是简单的线性映射，所以反映射的步骤如公式\ref{eq:3D_NDC_Mapping} 所示，公式(1) 为$X$，$Y$轴的反映射，公式(2)为$Z$轴的反映射，${L}_{volumesize}$ 为$X$或$Y$ 轴上三维纹理的大小，${L}_{volumesize}$ 为$Z$轴上三维纹理的大小，${X}_{volumetex}$ 为$X$或$Y$轴上的纹理坐标，${Z}_{volumetex}$ 为$Z$ 轴上的纹理坐标。
\begin{eqnarray}
    \left\{ \begin{matrix}
   {{X}_{NDC}}={{X}_{volumetex}}\times {{L}_{volumesize}}\times 2.0-1.0 & (1)  \\
   {{Z}_{NDC}}={{Z}_{volumetex}}\times {{L}_{volumesize}} & (2)  \\
\end{matrix} \right.
    \label{eq:3D_NDC_Mapping}
\end{eqnarray}

得到屏幕空间下的坐标以后，根据屏幕坐标计算世界坐标系下的位置。屏幕坐标系下的点$P$ 的位置为$\left( x,y,z \right)$，点$P$用屏幕空间坐标系下的三个基向量$\vec{a}$、$\vec{a}$ 和$\ vec{a}$ 表示,则表达式为公式\ref{eq:3ele}。
\begin{eqnarray}
    P=x\times \vec{a}+y\times \vec{a}+z\times \vec{a}
    \label{eq:3ele}
\end{eqnarray}

坐标系的转换可以理解为基向量的变化，根据这个思想，我们需要找到这个点世界坐标系下基向量的三个系数，由于没有直观的映射关系，这三个系数比较难计算，可以先从相机坐标系入手。在渲染过程中，相机的输入参数有三个：相机位置信息$C_{pos}$、 相机的目标位置$C_{tar}$、 相机的朝向$\vec{C_{up}}$，这三个信息都是世界坐标系下的值。相机的三个基向量在世界坐标系下的表示如公式\ref{eq:cam3ele}所示。
\begin{eqnarray}
    \left\{ \begin{matrix}
   \vec a={{C}_{tar}}-{{C}_{pos}}  \\
   \vec b=  \vec {C_{up}}\\
   \vec c= \vec a \times \vec b  \\
\end{matrix} \right.
    \label{eq:cam3ele}
\end{eqnarray}
其中$\vec a$为$Z$轴方向，$\vec b$为$Y$轴方向，$\vec c$为$X$ 轴方向，将屏幕坐标系$X$轴的分量$x$ 和$Y$ 轴的分量$y$与$\vec c$ 和$\vec a$相乘，可以得到世界坐标系下，当前点$P$相对于相机位置的$X$，$Y$轴方向的偏移$x^{'}$和$y^{'}$。在描述三维纹理的小节中提到，$Z$方向是指数级的变化，所以$Z$方向需要做另外的变换，变换如公式\ref{eq:zchange}所示。
\begin{eqnarray}
{{W}_{z}}={{S}_{z}}^{2}\times D
    \label{eq:zchange}
\end{eqnarray}
其中${S}_{z}$为屏幕坐标系下的深度值，${W}_{z}$为世界坐标系$Z$方向的分量，$D$为三维纹理在世界坐标系下$Z$分量下的最大值。由$x^{'}$、$y^{'}$ 和${W}_{z}$的值可知，点$P$在世界坐标系下以相机的位置为参考点，偏移量为$\left( {{x}^{'}}\times {{W}_{z}},{{y}^{'}}\times {{W}_{z}},{{W}_{z}} \right)$。 根据相机的位置信息可知点$P$在世界坐标系下的位置$W_{ppos}$为$\left( {{x}^{'}}\times {{W}_{z}},{{y}^{'}}\times {{W}_{z}},{{W}_{z}} \right)+{{C}_{pos}}$。


得到$W_{ppos}$之后，计算器着色器将计算写入三维纹理中的值：内散射值和消光系数的指数值。消光系数的指数值和介质的密度和厚度有关，将$W_{ppos}$作为输入参数传入柏林噪声函数得到密度$Density$，三维纹理把介质沿$Z$方向切成$N$ 块薄片，当前例子下$N=64$，当前薄片的厚度为前一个粒子的$z_p$值减去当前粒子的$z_c$值，由公式\ref{eq:zchange}可以求得$z_p$ 和$z_c$，$z_p$和$z_c$的差值即为厚度。消光系数的指数值$\tau$计算如公式\ref{eq:traexp} 所示，$\omega$为控制系数，控制消光的强弱。
\begin{eqnarray}
\tau =\omega \times Density\times \left( {{z}_{p}}-{{z}_{c}} \right)
    \label{eq:traexp}
\end{eqnarray}

内散射光线的值与入射光线和相位方程有关，入射光线由场景中的光源决定，各个光源对粒子的影响在章节\ref{multilight}中有详细的描述，将场景中所有光源的入射光线值的和记为$L_s$。 雾的散射模型为米氏散射，散射方程为公式\ref{eq:LTE-11}。$\mu$为视线和入射光线夹角的余弦值，所以内散射值计算如公式\ref{eq:inscal}所示。
\begin{eqnarray}
{{L}_{\text{in}s}}={{L}_{s}}\times {{P}_{HG}}\left( \mu ,g \right)
    \label{eq:inscal}
\end{eqnarray}

计算得到内散射光线值存放在纹理的$RGB$通道中，消光系数存放在$Alpha$通道中，每个通道的数据类型为浮点数，然后将这些值存放在三维纹理对应的坐标中。计算着色器的大小和三维纹理一致，因此计算着色器每个单元在全局工作组中的位置$gl\_GlobalInvocationID.xyz$便为三维纹理对应的存储坐标。
\section{Ray-marching算法求解散射积分方程}
本文算法的最后一步是求解散射方程，这是一个迭代的过程，不同视线之间的计算互不干扰，但是每一根视线线上点的计算存在数据依赖关系，所以只能使用$X \times Y \times 1$大小的计算着色器。


在计算着色器中处理光线行进步骤的迭代计算，需要得到两个值，并将结果存放在第二个三维纹理中，第一个值是粒子内散射值的总和，第二个值为介质在不同深度下的消光系数的指数值。在前一小节，已经计算了粒子的内散射光线，但是这个光线同样要在介质中经过一段距离的传播才能到达相机，我们需要计算每个粒子内散射光线最终进入相机的内散射光线的总和。此外，上一小节计算的消光系数的指数值$\tau$ 是单个粒子的值，这个章节需要不同厚度的介质总的消光系数指数值，这个值用来计算处于场景中不同深度的物体的反射光线对相机的贡献。

每个计算着色器单元处理一根光线上的计算，纹理每个纹素包含四个浮点型的数据，$RGB$ 通道用来保存最终内散射光线的颜色值，$Alpha$通道用来保存当前深度下的消光系数指数值。具体计算步骤如下：
\begin{itemize}
\item 读取当前视线下第$m$个粒子的内散射光线和消光系数指数值，$m$从0开始，最大值不超过$N$，$N$为三维纹理$Z$方向的最大分量；
\item 将当前$m$点的消光系数指数值增加到一个用来存放总的消光系数的累加寄存器中，用比尔― 朗伯定律计算$m$ 点的光线透射比；
\item 根据透射比计算$m$点的内散光线的透射光线，即最终达到相机的光线值；
\item 将透射光线的值和消光系数累加寄存器中的值存放到三维纹理中，对应的纹理坐标$X$，$Y$轴的分量为计算着色器的$gl\_GlobalInvocationID.xy$，$Z$方向的坐标值为$m$;
\item 将$m$值增加一，并且继续从步骤一开始执行；
\end{itemize}

用图来更加清晰地阐明这个步骤，如图\ref{pic_accumulating}所示。
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.95\textwidth,height=6.0cm]{figures/accumulating}
    \caption{求解散射方程}
    \label{pic_accumulating}
\end{figure}
当前步骤按图中从左向右的顺序执行，最左边的纹理是单个粒子散射计算的结果，其为输入参数。从这个三维纹理的$Z$方向对这些散射值使用计算着色器进行迭代计算。中间的图为计算着色器在$Z$方向从$0$层到$N-1$ 层的运算。计算的结果储存到右边的三维纹理中，三维纹理的颜色值随着$Z$的增大而增大，在视觉上的感受是雾越厚，雾的颜色越浓。

\section{级联阴影算法及优化}
\label{Shadow}
\subsection{级联阴影}
在计算单个粒子的内散射光线值时需要使用阴影因子，我们可以使用阴影贴图技术\scite{SD02}计算阴影因子，但是普通的阴影贴图技术对分辨率要求较高，在低分辨率下走样严重，场景越大需要的阴影贴图分辨率越高。为了得到更好的雾效和体积光，我们使用级联阴影技术作为本文算法中计算阴影因子的方法。级联阴影的思想如下，将场景划分为几个不同的部分，对每个部分分别生成不同分辨率的阴影贴图，划分的依据为场景到相机的距离。级联阴影生成阴影贴图的方式如图\ref{pic_csm} 所示，图中红色梯形为视锥体的范围，将视锥体中的场景按照远近分为三个部分，分别生成不同分辨率的纹理，越靠近眼睛的区域生成的纹理分辨率越高。根据透视投影的原则，相同大小的物体在近处映射到屏幕上的面积比远处的映射面积大得多。距离眼睛较近的地方需要高分辨率的阴影纹理来防止阴影效果走样，离相机较远的地方并不需要高分辨率的阴影纹理，高分辨的阴影纹理反而会加重内存的负担。当屏幕上多个像素对应阴影贴图中一个像素或者屏幕上一个像素对应阴影贴图中多个像素时都会存在走样的情况，最理想的情况是屏幕上的像素与阴影贴图中的像素为1:1 。
\begin{figure}[htbp]
    \centering
    \includegraphics[width=.5\linewidth]{figures/csm}
    \caption{级联阴影图}
    \label{pic_csm}
\end{figure}

使用级联阴影算法，渲染时每帧需要执行以下步骤：
\begin{itemize}
\item 将视锥体分块；
\item 分别计算每个子视锥体的投影矩阵；
\item 为每个子视锥体生成一张阴影贴图；
\item 计算光照时，将片元投影到不同的子视锥体中，确定当前片元应该使用阴影贴图。找到合适的阴影贴图以后，采样阴影贴图中的深度值，计算阴影因子，计算当前片元的光照值；
\end{itemize}
在大型场景中，使用级联阴影可以更加合理地分配阴影贴图的资源，让近处的物体可以有更好的阴影效果。
\subsubsection{分割视锥体}
在级联阴影中最重要的部分就是如何去划分视锥体，怎样将视锥体的子块分布更加合理。因为级联阴影根据远近来处理场景中的物体，所以最常想到的一个划分办法是按视锥体中的$Z$轴方向对视锥体进行划分。视锥体的近平面的深度值为0，远平面为1，
划分过程如图\ref{pic_splitfrustum} 所示，图中最左边的图为视锥体，中间和右边两幅图分别为将视锥体分为两个部分和三个部分的示意图，红色虚线为分割线，中间的图的分割线为$Z$方向的二等分线，右边的图的分割线为$Z$方向的三等分线。
\begin{figure}[htbp]
    \centering
    \includegraphics[width=.7\linewidth]{figures/splitfrustum}
    \caption{视锥体分割图}
    \label{pic_splitfrustum}
\end{figure}
在实际应用中，动态场景中每一帧都需要重新分割视锥体，渲染时分割部分的边缘会产生闪烁现象。一般做法是为每个场景生成静态级联间隔集。沿$Z$轴方向根据间隔集划分视锥体。间隔集由以下几个因素决定：
\begin{itemize}
\item 当前场景的深度范围。当场景的深度范围较大，则间隔集里的元素也会增多从而分割出更多的子视锥体；
\item 相机与物体的距离。当相机非常靠近地面或者物体时，间隔集需要能够在近处分割更多的子视锥体以保证渲染效果；相机与物体较远时，比如航拍，则需要的更少的级联间隔集；
\end{itemize}

\subsection{阴影贴图滤波}
\label{shadowfilter}
由上述算法描述可知，我们使用级联阴影算法时来生成阴影时，需要多张阴影纹理，会加大内存的负担，场景越大，这个弊端会越明显，此外，阴影贴图技术存在两个问题，第一个问题是低分辨下阴影边缘存在严重的锯齿，第二个问题是硬阴影，遮挡物离阴影很远时，阴影边缘依旧很明显。为了解决这些问题，我们使用阴影贴图滤波技术，本文算法生成低分辨率的阴影贴图，再对阴影贴图进行滤波以得到和使用高分辨率阴影贴图相似质量的渲染效果，降低了阴影贴图分辨率的纹理，可以减少渲染内存的开销，滤波以后抗锯齿问题也得到解决，并且在滤波时，阴影到遮挡物的距离是参考因素之一，所以硬阴影的问题也得到改善。

本文在国内外现状中提到很多处理阴影滤波的方式，包括VSM\scite{myers2007variance}，CSM\scite{annen2007convolution}，ESM\scite{annen2008exponential}，Transmittance Function Mapping\scite{delalandre2011transmittance} 和Fourier Opacity Mapping\scite{jansen2010fourier}等。这些滤波算法解决两个方面的问题，第一个是对阴影进行滤波，减少边缘锯齿，第二个是利用距离控制阴影的软硬程度。PCF滤波技术使用多重采样和插值函数对原有的阴影贴图进行处理，多重采样会增加性能的负担，PCF不支持提前滤波，需要在阴影贴图生成以后再进行滤波操作，这两个缺点都会影响算法的效率，此外，基于采样的阴影滤波方式都会有二次走样的问题。CSM支持提前滤波，CSM在遮挡体靠近阴影时阴影贴图会出现抖动情况，阴影的渲染结果出现条纹状的波纹，VSM比CSM稳定，但是VSM需要消耗额外的内存来存储阴影深度的平方值。ESM不需要多重采样，支持提前滤波，并不需要额外的内存消耗，阴影效果也没有抖动现象，相对来说，指数阴影贴图是本文算法中最优的解决方案。


下面介绍ESM的原理以及在本文算法中的应用。在阴影贴图技术中，我们计算阴影时，在阴影里时阴影因子为0，不在阴影里是阴影因子为1，图\ref{piccomshadowesm}中的左图为普通阴影贴图技术生成的阴影效果，这种阴影通常会容易产生锯齿，边界生硬。如果我们再0 和1 之间不是梯度的过渡，而是平滑过渡，那么阴影效果会更加柔和。指数阴影贴图的产生基于这个思想，选用合适的数学函数去模拟阴影边界的过渡过程，下面内容会介绍ESM 的数学的理论基础。

\begin{figure*}[!htb]
\makeatletter
\renewcommand{\@thesubfigure}{\hskip\subfiglabelskip}
\makeatother
    \centering
    \subfigure[普通阴影贴图渲染效果]{
    \includegraphics[width=0.4\textwidth, height=5.0cm]{figures/shadowmap}}
    \subfigure[指数阴影贴图渲染效果]{
    \includegraphics[width=0.4\textwidth, height=5.0cm]{figures/esm}}
    \caption{二维和三维Ray-marching效果图对比}
    \label{piccomshadowesm}
\end{figure*}


我们对阴影因子的计算可以表示为公式\ref{eq:shadow}。
\begin{eqnarray}
   s\left( x \right)=f\left( d\left( x \right),z\left( p \right) \right)
    \label{eq:shadow}
\end{eqnarray}
其中，$s\left( x \right)$表示阴影因子的值，$d\left( x \right)$ 表示相机空间下的片元$x$ 在光源空间下的深度值，$z\left( p \right)$为$x$映射到光源空间下的纹理坐标在阴影纹理中采样得到的深度值，$p$ 为片元$x$映射到光源空间下的屏幕坐标位置。基本阴影贴图$s\left( x \right)$的函数如公式\ref{eq:basic_shadow} 所示，这是一个阶梯函数。
\begin{eqnarray}
  s(x)=\left\{ \begin{matrix}
   0 & d\left( x \right)>z\left( p \right)  \\
   1 & d\left( x \right)\le z\left( p \right)  \\
\end{matrix} \right.
    \label{eq:basic_shadow}
\end{eqnarray}

对阴影贴图进行处理就是将阶梯函数变成平滑的曲线，如图\ref{pic_shadowfun}所示
\begin{figure}[htbp]
    \centering
    \includegraphics[width=.5\linewidth]{figures/shadowfun}
    \caption{阴影函数图像对比图}
    \label{pic_shadowfun}
\end{figure}
图中，红色表示普通阴影贴图的阶梯函数，绿色为我们需要模拟的平滑的阴影函数。
在指数阴影贴图中，我们用指数函数来模拟$s\left( x \right)$函数，表达式如公式\ref{eq:esm}所示，$d$ 为片元在光源空间下的深度，$z$为阴影贴图中的值，$c$为控制系数，控制滤波的强弱，这个函数可以近似模拟图\ref{pic_shadowfun} 中绿色的线，得到更加平滑的阴影，指数阴影贴图生成的阴影效果如图\ref{piccomshadowesm}中右图所示。
\begin{eqnarray}
   f\left( d,z \right)={{e}^{-c\left( d-z \right)}}={{e}^{-cd}}{{e}^{cz}}
    \label{eq:esm}
\end{eqnarray}

本文算法生成多张级联阴影贴图以后会使用指数阴影贴图技术对阴影贴图进行滤波，用指数阴影贴图计算阴影因子，解决走样的问题。此外，使用滤波技术还可以减少相机在漫游过程中纹理出现抖动的情况，原理如图\ref{pic_filter}所示。图中锯齿状的物体为产生阴影的物体，物体在阴影纹理中沿左下角往右上角移动，上面两张图是没有纹理滤波的情况，第$n$帧阴影纹理值和第$n+1$帧阴影纹理值存在明显的跳变过程。下面两张图是有纹理滤波的情况，两帧之间的阴影值平滑过度，能够缓解因为相机移动导致的阴影效果不稳定现象。
\begin{figure}[htbp]
    \centering
    \includegraphics[width=.7\linewidth]{figures/filter}
    \caption{动态场景中N帧和N+1帧阴影纹理对比图}
    \label{pic_filter}
\end{figure}

\section{场景最终结果的计算}
得到场景中不同深度下的累计内散射值和消光系数的指数值以后，后续渲染步骤就可以将散射效果应用到原始场景中形成雾效。总体的计算如公式\ref{eq:FinalColor}所示。
\begin{eqnarray}
F_{color}=S_{color} \times T + IS_{color}
    \label{eq:FinalColor}
\end{eqnarray}
其中$F_{color}$为场景中最终的颜色值，$S_{color}$为场景原始的颜色值，$T$为透射比，$IS_{color}$为内散射光线的总和。
因为在三维纹理中存储的是每条视线上离散点的计算值，所以我们将效果应用到场景中时只需要考虑场景的深度在三维纹理中对应的位置，在前向着色渲染管线和延迟着色管线中都可以方便地取得场景的深度信息，所以本文算法可以兼容这两种渲染流程。


效果应用步骤在片元着色器中完成，得到场景深度之后，根据公式\ref{eq:zchange}可以求得当前片元在三维纹理中的$Z$方向的坐标值，因为屏幕的$X$，$Y$方向和三维纹理的$X$，$Y$方向一致，所以只需要对屏幕坐标进行线性变换就可以得到当前片元在三维纹理中$X$，$Y$方向的坐标值。得到当前片元的三维纹理采样坐标之后，从纹理中取出当前深度对应的内散射值和消光系数指数值，我们根据比尔―朗伯定律得到透射比，计算当前片元到达眼睛的透射光线。
\begin{figure*}[!htb]
\makeatletter
\renewcommand{\@thesubfigure}{\hskip\subfiglabelskip}
\makeatother
    \centering
    \subfigure[(a)]{
    \includegraphics[width=0.45\textwidth, height=4.0cm]{figures/FogColor_rgb}}
    \subfigure[(b)]{
    \includegraphics[width=0.45\textwidth, height=4.0cm]{figures/FogColor_transmitte}}
     \subfigure[(c)]{
    \includegraphics[width=0.45\textwidth, height=4.0cm]{figures/scenecolor}}
    \subfigure[(d)]{
    \includegraphics[width=0.45\textwidth, height=4.0cm]{figures/finalColor}}
    \caption{渲染结果展示}
    \label{pic1-shaderRes}
\end{figure*}

如图\ref{pic1-shaderRes}所示，图(a)为当前场景深度下三维纹理中的散射光线的值，图(b) 为当前场景深度下每个片元的透射比，图(c)为场景的原始颜色值，图(d)为在场景中添加雾效的效果图。

本文算法在前向渲染和延迟着色渲染中的应用比较灵活，此外对透明物体的处理也一样灵活，如图
\ref{pic_transObject}所示。
\begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth,height=4.5cm]{figures/transObject}
    \caption{存在透明物体的场景下算法的应用}
    \label{pic_transObject}
\end{figure}
其中，视线的起点为不透明物体的位置，终点为相机的位置，在视线传播过程中的小长方形代表视线上的离散粒子，长方形有两部分组成，上边部分表示每个粒子的内散射光线，下边部分表示每个粒子的消光系数，这些数据存放在三维纹理中。视线的路径上有两个透明物体，本文算法在这种情况下也可以很好地应用雾效。现有的处理透明物体较为普遍的方法有Depth Peeling\scite{Mammen:89}，OIT\scite{Everitt:02}等，这些算法都是将透明物体的片元进行存储并按照深度排序，在最后渲染时有序进行混合。我们可以得到这些透明物体多层片元的深度值，然后按深度值对三维纹理进行采样，得到当前片元的雾效。图中透明物体上的灰色短箭头代表当前透明物体前后片元应该采样的三维纹理值，不透明物体的灰色短箭头代表不透明物体片元应该采样的三维纹理值，对五个片元的值进行混合，得到最终的颜色。


\section{本章小节}
本章首先对本文算法的核心思想进行了概述，对算法的具体步骤进行描述，然后对算法中阴影处理，散射计算和主要数据结构做了详细的介绍，此外还介绍了多光源场景下散射计算的预处理步骤，最后介绍如何将本文算法生成的效果与现有的渲染管线和特殊的场景相结合。
